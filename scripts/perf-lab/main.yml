name: spring-quarkus-perf-comparison
states:
  env.run.host.user: someuser
  env.run.host.name: 127.0.0.1
  env.run.host.target: ${{env.run.host.user}}@${{env.run.host.name}}

  config.jvm.version: 25.0.1-tem
  config.jvm.graalvm.version: 25.0.1-graalce

  config.quarkus.version: #3.28.3
  config.springboot.version: #3.5.6

  config.jvm.memory: #-Xmx128m
  config.jvm.args: #-XX:+UseNUMA

  config.quarkus.native_build_options: #-Dquarkus.native.native-image-xmx=<maximum_memory>
  config.springboot.native_build_options:

  config.resources.cpu.app: 0-3
  config.resources.cpu.db: 4-6
  config.resources.cpu.load_generator: 7-9
  config.resources.cpu.1st_request: 10

  config.profiler.name: none #jfr flamegraph
  config.profiler.events: cpu

  config.repo.branch: main
  config.repo.url: https://github.com/quarkusio/spring-quarkus-perf-comparison.git

  config.num_iterations: 3

  APP_CMD_PREFIX: taskset --cpu-list ${{config.resources.cpu.app}}
  LOAD_GEN_CMD_PREFIX: taskset --cpu-list ${{config.resources.cpu.load_generator}}
  RUN.WRK_BIN: ${{LOAD_GEN_CMD_PREFIX}} jbang -R -XX:+UseNUMA wrk@hyperfoil

  DROP_OS_FILESYSTEM_CACHES:
  QUARKUS_MAVEN_OPTIONS:
  PAUSE_TIME: 5
  PROFILER_JVM_ARGS:
  BASE_JAVA_CMD: ${{APP_CMD_PREFIX}} java ${{config.jvm.memory}} ${{config.jvm.args}} ${{PROFILER_JVM_ARGS}}
  TESTS : [test-build, measure-build-times, measure-time-to-first-request, measure-rss, run-load-test]
  RUNTIMES: [quarkus3-jvm, quarkus3-native, spring3-jvm, spring3-jvm-aot, spring3-native]
  TARGET_URL: http://localhost:8080/fruits
  QUARKUS-PLATFORM-ARTIFACT-ID: quarkus-bom
  PROJ_REPO_NAME: spring-quarkus-perf-comparison
  METRICS_DIR: /tmp
  ASYNC_PROFILER: async-profiler
  RUNTIMECMDS:
    - name: quarkus3-jvm
      type: jvm
      dir: ${{QUARKUS3_DIR}}
      updateScript: update-quarkus-version
      updateVersion: ${{config.quarkus.version}}
      buildCmd: "./mvnw ${{QUARKUS_MAVEN_OPTIONS}} clean package -DskipTests"
      runCmd: "${{BASE_JAVA_CMD}} -jar ${{QUARKUS3_DIR}}/target/quarkus-app/quarkus-run.jar"
    - name: quarkus3-native
      type: native
      dir: ${{QUARKUS3_DIR}}
      updateScript: update-quarkus-version
      updateVersion: ${{config.quarkus.version}}
      buildCmd: "./mvnw ${{QUARKUS_MAVEN_OPTIONS}} clean package -DskipTests -Pnative ${{config.quarkus.native_build_options}}"
      runCmd: "${{APP_CMD_PREFIX}} ${{QUARKUS3_DIR}}/target/quarkus3-runner ${{config.jvm.memory}}"
    - name: spring3-jvm
      type: jvm
      dir: ${{SPRING3_BOOT_DIR}}
      updateScript: update-spring-boot-version
      updateVersion: ${{config.springboot.version}}
      buildCmd: "./mvnw clean package -DskipTests"
      runCmd: "${{BASE_JAVA_CMD}} -jar ${{SPRING3_BOOT_DIR}}/target/springboot3.jar"
    - name: spring3-jvm-aot
      type: jvm
      dir: ${{SPRING3_BOOT_DIR}}
      updateScript: update-spring-boot-version
      updateVersion: ${{config.springboot.version}}
      buildCmd: "./mvnw clean compile spring-boot:process-aot package -DskipTests"
      runCmd: "${{BASE_JAVA_CMD}} -Dspring.aot.enabled=true -jar ${{SPRING3_BOOT_DIR}}/target/springboot3.jar"
    - name: spring3-native
      type: native
      dir: ${{SPRING3_BOOT_DIR}}
      updateScript: update-spring-boot-version
      updateVersion: ${{config.springboot.version}}
      buildCmd: "./mvnw clean -Pnative -DskipTests native:compile package ${{config.springboot.native_build_options}}"
      runCmd: "${{APP_CMD_PREFIX}} ${{SPRING3_BOOT_DIR}}/target/springboot3 ${{config.jvm.memory}}"

scripts:
  update-state:
    - sh: echo $(realpath ~)
    - set-state: RUN.BASE_DIR
    - set-state: RUN.REPO_DIR ${{BASE_DIR}}/spring-quarkus-perf-comparison
    - set-state: RUN.PROJ_REPO_DIR ${{REPO_DIR}}/${{PROJ_REPO_NAME}}
    - set-state: RUN.SCRIPTS_DIR ${{PROJ_REPO_DIR}}/scripts/perf-lab
    - set-state: RUN.HELPER_SCRIPTS_DIR ${{SCRIPTS_DIR}}/scripts
    - set-state: RUN.SPRING3_BOOT_DIR ${{PROJ_REPO_DIR}}/springboot3
    - set-state: RUN.QUARKUS3_DIR ${{PROJ_REPO_DIR}}/quarkus3
    - set-state: RUN.ASYNC_PROFILER_DIR ${{BASE_DIR}}/${{ASYNC_PROFILER}}

  output-vars:
    - log: |
        "Config: ${{config}}"
        "ENV: ${{env}}"
        "BASE_DIR: ${{BASE_DIR}}"
        "REPO_DIR: ${{REPO_DIR}}"
        "SCRIPTS_DIR: ${{SCRIPTS_DIR}}"
        "SPRING3_BOOT_DIR: ${{SPRING3_BOOT_DIR}}"
        "QUARKUS3_DIR : ${{QUARKUS3_DIR}}"
        "RUNTIMECMDS: ${{RUNTIMECMDS}}"

  capture-repo-info:
    - sh: cd ${{PROJ_REPO_DIR}}
    - sh: git rev-parse HEAD
    - set-state: RUN.config.repo.commit

  cleanup-env:
    - script: sudo
      with:
        command: rm -Rf ${{PROJ_REPO_DIR}}

  config-env:
    - script: sudo
      with:
        command: rm -Rf ${{REPO_DIR}}/logs
    - sh: mkdir -p ${{REPO_DIR}}/logs

  clone-repo:
    - script: sudo
      with:
        command: rm -Rf ${{REPO_DIR}}
    - sh: mkdir -p ${{REPO_DIR}}/logs
    - sh: cd ${{REPO_DIR}}
    - log: Cloning project repo ${{config.repo.branch}}@${{config.repo.url}}
    - sh: git clone -b ${{config.repo.branch}} ${{config.repo.url}}
    - sh: cd ${{PROJ_REPO_NAME}}
    - log: Checked out repo
    - sh: git remote get-url origin
    - sh: git branch --show-current

  update-spring-boot-version:
    - script: check-dependency-exists
      with:
        groupId: org.springframework.boot
        artifactId: spring-boot-starter-parent
        version: ${{VERSION}}
    - sh: ./mvnw versions:update-parent "-DparentVersion=[${{VERSION}}]" -DskipResolution=true

  update-quarkus-version:
    - script: check-dependency-exists
      with:
        groupId: io.quarkus.platform
        artifactId: quarkus-bom
        version: ${{VERSION}}
    - sh: ./mvnw versions:set-property -Dproperty=quarkus.platform.version -DnewVersion=${{VERSION}}

  start-test-services:
    - sh: ${{PROJ_REPO_DIR}}/scripts/infra.sh -c 3 -p '${{config.resources.cpu.db}}' -s

  stop-test-services:
    - sh: ${{PROJ_REPO_DIR}}/scripts/infra.sh -d

  run-tests:
    - sh: java -version
    - sh: echo $$
    - set-state: RUN.SHELL_PID
    - for-each: RUNTIME ${{RUNTIMES}}
      then:
        - set-state: RUNTIMECMD ${{RUNTIMECMDS[?(@.name == '${{RUNTIME}}')]}}
        - log: "Updating version: ${{RUNTIMECMD.updateVersion:}}"
        - script: ${{RUNTIMECMD.updateScript:abort-script-not-found}}
          with:
            DIR: ${{RUNTIMECMD.dir}}
            VERSION: ${{RUNTIMECMD.updateVersion:}}
        - log: "Testing: ${{RUNTIME}}"
        - for-each: TEST ${{TESTS}}
          then:
          - script: ${{TEST}}
            with:
              RUNTIME: ${{RUNTIMECMD}}

  abort-script-not-found:
    - abort: script not found

  test-build:
    - log: Test Build - ${{RUNTIME.name}}
    - sh: cd ${{RUNTIME.dir}}
    - sh: java -version
    - sh: ${{RUNTIME.buildCmd}}
      watch:
      - regex: BUILD FAILURE
        then:
          - abort: failed to build ${{RUNTIME.name}}

  measure-build-times:
    - log: Build times
    - sh: cd ${{RUNTIME.dir}}
    - log: JVM version
    - sh: java -version
    - log: Graal VM Version
    - sh: $GRAALVM_HOME/bin/java -version
    - set-state: TYPE ${{RUNTIME.type}}
    - for-each: ITERATION ${{=[...Array(${{config.num_iterations}}).keys()]}}
      then:
        - queue-download: ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-${{ITERATION}}.log
        - script: sync-drop-fs-cache
        - sh: /usr/bin/time -p ${{RUNTIME.buildCmd}} 2>&1 >${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-${{ITERATION}}.log | grep real | awk '{print $2}'
        - set-state: BUILD_TIME
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.build.timings
            value: ${{BUILD_TIME}}

        # If its a native build, gather the native build rss as well
        - read-state: ${{TYPE}}
          then:
            - regex: native
              then:
                - sh: "sed -n 's/.*Peak RSS: \\([0-9.]*\\)GB.*/\\1/p' ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-${{ITERATION}}.log"
                - set-state: NATIVE_BUILD_RSS
                - script: state-array-push
                  with:
                    array: RUN.output.results.${{RUNTIME.name}}.build.native.rss
                    value: ${{NATIVE_BUILD_RSS}}
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.build.avBuildTime
        array: RUN.output.results.${{RUNTIME.name}}.build.timings

    - read-state: ${{TYPE}}
      then:
        - regex: native
          then:
            # Capture average native build RSS
            - script: state-array-calc-avg
              with:
                var-name: RUN.output.results.${{RUNTIME.name}}.build.avNativeRSS
                array: RUN.output.results.${{RUNTIME.name}}.build.native.rss

            # The following metrics should be the same in all test iterations, so just pick the 1st
            # Capture the binary size
            - sh: "sed -n 's/^[[:space:]]*\\([0-9.]*\\)MB in total image size.*/\\1/p' ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.native.binarySize

            # Capture the number of classes
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods found reachable\" | awk '{print $1}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.classCount

            # Capture the number of fields
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods found reachable\" | awk '{print $3}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.fieldCount

            # Capture the number of methods
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods found reachable\" | awk '{print $6}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.methodCount

            # Capture the number of classes registered for reflection
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods registered for reflection\" | awk '{print $1}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.reflectionClassCount

            # Capture the number of fields registered for reflection
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods registered for reflection\" | awk '{print $3}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.reflectionFieldCount

            # Capture the number of methods registered for reflection
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods registered for reflection\" | awk '{print $6}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.reflectionMethodCount

  measure-time-to-first-request:
    - log: Measuring Time to first request
    - sh: java -version
    - sh: cd ${{RUNTIME.dir}}
    - sh: ${{RUNTIME.buildCmd}}
    - for-each: ITERATION ${{=[...Array(${{config.num_iterations}}).keys()]}}
      then:
        - queue-download: ${{REPO_DIR}}/logs/measure-time-to-first-request-${{RUNTIME.name}}-${{ITERATION}}.log
        - script: start-test-services
        - script: sync-drop-fs-cache
        - sh: ${{RUNTIME.runCmd}} &>${{REPO_DIR}}/logs/measure-time-to-first-request-${{RUNTIME.name}}-${{ITERATION}}.log &
        - sh: APP_PID=$!
        - sh: timeout 60s bash -c "taskset --cpu-list ${{config.resources.cpu.1st_request}} ${{HELPER_SCRIPTS_DIR}}/time-to-1st-request.sh ${{TARGET_URL}}"
          then:
            - regex: Terminated
              then:
                - sh: kill -15 $APP_PID
                - abort: Run ${{RUNTIME.runCmd}} didn't start within allotted timeout
            - regex: .*\D.*
              then:
                - sh: kill -15 $APP_PID
                - abort: Timeout script returned a non-numeric value
              else:
                - set-state: START_TIME
        - sh: kill -15 $APP_PID
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.startup.timings
            value: ${{START_TIME}}
        - sh: sleep ${{PAUSE_TIME}}
        - script: stop-test-services
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.startup.avStartTime
        array: RUN.output.results.${{RUNTIME.name}}.startup.timings

  measure-rss:
    - log: Measuring RSS
    - sh: java -version
    - sh: cd ${{RUNTIME.dir}}
    - sh: ${{RUNTIME.buildCmd}}
    - for-each: ITERATION ${{=[...Array(${{config.num_iterations}}).keys()]}}
      then:
        - queue-download: ${{REPO_DIR}}/logs/measure-rss-${{RUNTIME.name}}-${{ITERATION}}.log
        - script: start-test-services
        - script: sync-drop-fs-cache
        - sh: ${{RUNTIME.runCmd}} &>${{REPO_DIR}}/logs/measure-rss-${{RUNTIME.name}}-${{ITERATION}}.log &
        - sh: APP_PID=$!
        - sh: sleep ${{PAUSE_TIME}}
        - sh: pmap -x $APP_PID | grep total | awk '{print $4}'
          then:
            - set-state: RSS_STARTUP
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.rss.startup
            value: ${{= ${{RSS_STARTUP}}/1024 }}
        - sh: curl -s  ${{TARGET_URL}} > /dev/null
        - sh: pmap -x $APP_PID | grep total | awk '{print $4}'
          then:
            - set-state: FIRST_REQUEST
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.rss.firstRequest
            value: ${{= ${{FIRST_REQUEST}}/1024 }}
        - sh: kill -15 $APP_PID
        - sh: sleep ${{PAUSE_TIME}}
        - script: stop-test-services
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.rss.avStartupRss
        array: RUN.output.results.${{RUNTIME.name}}.rss.startup
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.rss.avFirstRequestRss
        array: RUN.output.results.${{RUNTIME.name}}.rss.firstRequest

  run-load-test:
    - log: Running workload
    - sh: cd ${{RUNTIME.dir}}
    - sh: ${{RUNTIME.buildCmd}}
    - for-each: ITERATION ${{=[...Array(${{config.num_iterations}}).keys()]}}
      then:
        - queue-download: ${{REPO_DIR}}/logs/wrk-warmup-${{RUNTIME.name}}-${{ITERATION}}.log
        - queue-download: ${{REPO_DIR}}/logs/load-test-${{RUNTIME.name}}-${{ITERATION}}.log
        - queue-download: ${{REPO_DIR}}/logs/wrk-${{RUNTIME.name}}-${{ITERATION}}.log
        - script: start-test-services
        - script: sync-drop-fs-cache
        - set-signal: LOAD_STEADY_STATE_START 1
        - sh: ${{RUNTIME.runCmd}} &>${{REPO_DIR}}/logs/load-test-${{RUNTIME.name}}-${{ITERATION}}.log &
        - sh: PID=$!
        - sh: echo $PID
        - set-state: JVM_PID
        - log: JVM_PID = ${{JVM_PID}}
        - read-state: ${{config.profiler.name}}
          then:
            - regex: "jfr|flamegraph"
              then:
                - script: async-profiler-install
                - script: async-profiler-configure
                - script:
                    name: async-profiler-run
                    async: true
                  with:
                    wait_start: LOAD_STEADY_STATE_START
                    pid: ${{JVM_PID}}
                    suffix: ${{ITERATION}}.html
                    format: ${{config.profiler.name}}
                    events: ${{config.profiler.events}}
                    delay: 10s
        - sh: sleep ${{PAUSE_TIME}}
        - sh: ${{RUN.WRK_BIN}} -t2 -c100 -d2m ${{TARGET_URL}} 2>&1 >${{REPO_DIR}}/logs/wrk-warmup-${{RUNTIME.name}}-${{ITERATION}}.log
        - regex: unable to connect
          then:
            - abort: unable to connect to target application
        - signal: LOAD_STEADY_STATE_START
        - sh: ${{RUN.WRK_BIN}} -t2 -c100 -d30s ${{TARGET_URL}} 2>&1 >${{REPO_DIR}}/logs/wrk-${{RUNTIME.name}}-${{ITERATION}}.log
        - sh: cat ${{REPO_DIR}}/logs/wrk-${{RUNTIME.name}}-${{ITERATION}}.log | grep "Requests/sec" | awk '{print $2}'
          then:
            - set-state: THROUGHPUT
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.load.throughput
            value: ${{THROUGHPUT}}
        - sh: cat ${{REPO_DIR}}/logs/wrk-${{RUNTIME.name}}-${{ITERATION}}.log | grep "Socket errors:" | sed -E 's/.*connectionErrors ([0-9]+).*/\1/'
          then:
            - regex: ^$
              then:
                - set-state: CONNECTION_ERRORS 0
              else:
                - set-state: CONNECTION_ERRORS
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.load.connectionErrors
            value: ${{CONNECTION_ERRORS}}

        - sh: cat ${{REPO_DIR}}/logs/wrk-${{RUNTIME.name}}-${{ITERATION}}.log | grep "Socket errors:" | sed -E 's/.*requestTimeouts ([0-9]+)/\1/'
          then:
            - regex: ^$
              then:
                - set-state: REQUEST_TIMEOUTS 0
              else:
                - set-state: REQUEST_TIMEOUTS
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.load.requestTimeouts
            value: ${{REQUEST_TIMEOUTS}}

        - sh: pmap -x $PID | grep total | awk '{print $4}'
          then:
            - set-state: RSS
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.load.rss
            value: ${{= ${{RSS}}/1024 }}
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.load.throughputDensity
            value: ${{= ${{THROUGHPUT}}/${{RSS}}*1024 }}
        - sh: kill -15 $PID
        - sh: sleep ${{PAUSE_TIME}}
        - script: stop-test-services
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.load.avThroughput
        array: RUN.output.results.${{RUNTIME.name}}.load.throughput
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.load.avMaxRss
        array: RUN.output.results.${{RUNTIME.name}}.load.rss
    - script: state-array-calc-max
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.load.maxThroughputDensity
        array: RUN.output.results.${{RUNTIME.name}}.load.throughputDensity
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.load.avConnectionErrors
        array: RUN.output.results.${{RUNTIME.name}}.load.connectionErrors
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.load.avRequestTimeouts
        array: RUN.output.results.${{RUNTIME.name}}.load.requestTimeouts

  download-metrics:
    - sh: mkdir -p ${{METRICS_DIR}}
    - script: sudo
      with:
        command: rm -Rf ${{METRICS_DIR}}/metrics.json
    - set-state: RUN.output.config ${{RUN.config}}
    - set-state: RUN.output.env ${{RUN.env}}
    - sh: echo '${{RUN.output}}' > ${{METRICS_DIR}}/metrics.json
      then:
      - regex: .*Permission denied
        then:
        - abort: Could not output metrics. Permission denied!
    - queue-download: ${{METRICS_DIR}}/metrics.json
#    - queue-download: ${{REPO_DIR}}/logs/*

hosts:
  target-host: ${{env.run.host.target}}

roles:
  test-runner:
    hosts:
      - target-host
    setup-scripts:
      - update-state
#      - output-vars
      - detect-os
      - capture-system-info
      - cleanup-env
      - config-env
      - ensure-requirements
      - clone-repo
      - capture-repo-info
      - stop-test-services
      - start-timestamp
    run-scripts:
      - run-tests
    cleanup-scripts:
      - stop-timestamp
      - download-metrics
      - stop-test-services
      - cleanup-env
